{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport Image from \"react-native-web/dist/exports/Image\";\nimport EventEmitter from 'eventemitter3';\nimport { Buffer } from 'buffer';\nvar Sockets = NativeModules.TcpSockets;\nimport { nativeEventEmitter, getNextId } from \"./Globals\";\n\nvar Socket = function (_EventEmitter) {\n  _inherits(Socket, _EventEmitter);\n\n  var _super = _createSuper(Socket);\n\n  function Socket() {\n    var _this;\n\n    _classCallCheck(this, Socket);\n\n    _this = _super.call(this);\n\n    _this._onDeviceDataEvt = function (evt) {\n      if (evt.id !== _this._id) return;\n\n      if (!_this._paused) {\n        var bufferData = Buffer.from(evt.data, 'base64');\n        _this._bytesRead += bufferData.byteLength;\n        var finalData = _this._encoding ? bufferData.toString(_this._encoding) : bufferData;\n\n        _this.emit('data', finalData);\n      } else {\n        _this._pausedDataEvents.push(evt);\n      }\n    };\n\n    _this._id = undefined;\n    _this._eventEmitter = nativeEventEmitter;\n    _this._msgEvtEmitter = new EventEmitter();\n    _this._timeoutMsecs = 0;\n    _this._timeout = undefined;\n    _this._encoding = undefined;\n    _this._msgId = 0;\n    _this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n    _this._lastSentMsgId = 0;\n    _this._paused = false;\n    _this._resuming = false;\n    _this._writeBufferSize = 0;\n    _this._bytesRead = 0;\n    _this._bytesWritten = 0;\n    _this._connecting = false;\n    _this._pending = true;\n    _this._destroyed = false;\n    _this._readyState = 'open';\n    _this._pausedDataEvents = [];\n    _this.readableHighWaterMark = 16384;\n    _this.writableHighWaterMark = 16384;\n    _this.writableNeedDrain = false;\n    _this.localAddress = undefined;\n    _this.localPort = undefined;\n    _this.remoteAddress = undefined;\n    _this.remotePort = undefined;\n    _this.remoteFamily = undefined;\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  _createClass(Socket, [{\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this._destroyed;\n    }\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this._pending;\n    }\n  }, {\n    key: \"connecting\",\n    get: function get() {\n      return this._connecting;\n    }\n  }, {\n    key: \"bytesWritten\",\n    get: function get() {\n      return this._bytesWritten;\n    }\n  }, {\n    key: \"bytesRead\",\n    get: function get() {\n      return this._bytesRead;\n    }\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      return this._timeout;\n    }\n  }, {\n    key: \"_setId\",\n    value: function _setId(id) {\n      this._id = id;\n\n      this._registerEvents();\n    }\n  }, {\n    key: \"_setConnected\",\n    value: function _setConnected(connectionInfo) {\n      this._connecting = false;\n      this._readyState = 'open';\n      this._pending = false;\n      this.localAddress = connectionInfo.localAddress;\n      this.localPort = connectionInfo.localPort;\n      this.remoteAddress = connectionInfo.remoteAddress;\n      this.remoteFamily = connectionInfo.remoteFamily;\n      this.remotePort = connectionInfo.remotePort;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(options, callback) {\n      if (this._id === undefined) this._setId(getNextId());\n\n      var customOptions = _objectSpread({}, options);\n\n      customOptions.host = customOptions.host || 'localhost';\n      customOptions.port = Number(customOptions.port) || 0;\n      this.once('connect', function () {\n        if (callback) callback();\n      });\n      if (customOptions.timeout) this.setTimeout(customOptions.timeout);else if (this._timeout) this._activateTimer();\n\n      if (customOptions.tlsCert) {\n        customOptions.tlsCert = Image.resolveAssetSource(customOptions.tlsCert).uri;\n      }\n\n      this._connecting = true;\n      this._readyState = 'opening';\n      Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n      return this;\n    }\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(timeout, callback) {\n      if (timeout === 0) {\n        this._clearTimeout();\n      } else {\n        this._activateTimer(timeout);\n      }\n\n      if (callback) this.once('timeout', callback);\n      return this;\n    }\n  }, {\n    key: \"_activateTimer\",\n    value: function _activateTimer(timeout) {\n      var _this2 = this;\n\n      if (timeout !== undefined) this._timeoutMsecs = timeout;\n\n      this._clearTimeout();\n\n      this._timeout = setTimeout(function () {\n        _this2._clearTimeout();\n\n        _this2.emit('timeout');\n      }, this._timeoutMsecs);\n    }\n  }, {\n    key: \"_clearTimeout\",\n    value: function _clearTimeout() {\n      if (this._timeout !== undefined) {\n        clearTimeout(this._timeout);\n        this._timeout = undefined;\n      }\n    }\n  }, {\n    key: \"setEncoding\",\n    value: function setEncoding(encoding) {\n      this._encoding = encoding;\n      return this;\n    }\n  }, {\n    key: \"setNoDelay\",\n    value: function setNoDelay() {\n      var _this3 = this;\n\n      var noDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this._pending) {\n        this.once('connect', function () {\n          return _this3.setNoDelay(noDelay);\n        });\n        return this;\n      }\n\n      Sockets.setNoDelay(this._id, noDelay);\n      return this;\n    }\n  }, {\n    key: \"setKeepAlive\",\n    value: function setKeepAlive() {\n      var _this4 = this;\n\n      var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var initialDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this._pending) {\n        this.once('connect', function () {\n          return _this4.setKeepAlive(enable, initialDelay);\n        });\n        return this;\n      }\n\n      if (initialDelay !== 0) {\n        console.warn('react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored');\n      }\n\n      Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n      return this;\n    }\n  }, {\n    key: \"address\",\n    value: function address() {\n      if (!this.localAddress) return {};\n      return {\n        address: this.localAddress,\n        family: this.remoteFamily,\n        port: this.localPort\n      };\n    }\n  }, {\n    key: \"end\",\n    value: function end(data, encoding) {\n      var _this5 = this;\n\n      if (data) {\n        this.write(data, encoding, function () {\n          Sockets.end(_this5._id);\n        });\n        return this;\n      }\n\n      if (this._pending || this._destroyed) return this;\n\n      this._clearTimeout();\n\n      Sockets.end(this._id);\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._pending || this._destroyed) return this;\n      this._destroyed = true;\n\n      this._clearTimeout();\n\n      Sockets.destroy(this._id);\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(buffer, encoding, cb) {\n      var _this6 = this;\n\n      var self = this;\n      if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n\n      var generatedBuffer = this._generateSendBuffer(buffer, encoding);\n\n      this._writeBufferSize += generatedBuffer.byteLength;\n      var currentMsgId = this._msgId;\n      this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n\n      var msgEvtHandler = function msgEvtHandler(evt) {\n        var msgId = evt.msgId,\n            err = evt.err;\n\n        if (msgId === currentMsgId) {\n          _this6._msgEvtEmitter.removeListener('written', msgEvtHandler);\n\n          _this6._writeBufferSize -= generatedBuffer.byteLength;\n          _this6._lastRcvMsgId = msgId;\n          if (self._timeout) self._activateTimer();\n\n          if (_this6.writableNeedDrain && _this6._lastSentMsgId === msgId) {\n            _this6.writableNeedDrain = false;\n\n            _this6.emit('drain');\n          }\n\n          if (cb) {\n            if (err) cb(new Error(err));else cb();\n          }\n        }\n      };\n\n      this._msgEvtEmitter.on('written', msgEvtHandler, this);\n\n      var ok = this._writeBufferSize < this.writableHighWaterMark;\n      if (!ok) this.writableNeedDrain = true;\n      this._lastSentMsgId = currentMsgId;\n      this._bytesWritten += generatedBuffer.byteLength;\n      Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n      return ok;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this._paused) return;\n      this._paused = true;\n      Sockets.pause(this._id);\n      this.emit('pause');\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (!this._paused) return;\n      this._paused = false;\n      this.emit('resume');\n\n      this._recoverDataEventsAfterPause();\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n    }\n  }, {\n    key: \"_recoverDataEventsAfterPause\",\n    value: function _recoverDataEventsAfterPause() {\n      var buffArray, readBytes, i, evtData, buffOffset, evt;\n      return _regeneratorRuntime.async(function _recoverDataEventsAfterPause$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!this._resuming) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 2:\n              this._resuming = true;\n\n            case 3:\n              if (!(this._pausedDataEvents.length > 0)) {\n                _context.next = 29;\n                break;\n              }\n\n              buffArray = [];\n              readBytes = 0;\n              i = 0;\n\n            case 7:\n              if (!(i < this._pausedDataEvents.length)) {\n                _context.next = 21;\n                break;\n              }\n\n              evtData = Buffer.from(this._pausedDataEvents[i].data, 'base64');\n              readBytes += evtData.byteLength;\n\n              if (!(readBytes <= this.readableHighWaterMark)) {\n                _context.next = 14;\n                break;\n              }\n\n              buffArray.push(evtData);\n              _context.next = 18;\n              break;\n\n            case 14:\n              buffOffset = this.readableHighWaterMark - readBytes;\n              buffArray.push(evtData.slice(0, buffOffset));\n              this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n              return _context.abrupt(\"break\", 21);\n\n            case 18:\n              i++;\n              _context.next = 7;\n              break;\n\n            case 21:\n              evt = {\n                id: this._pausedDataEvents[0].id,\n                data: Buffer.concat(buffArray).toString('base64')\n              };\n              this._pausedDataEvents = this._pausedDataEvents.slice(i);\n\n              this._onDeviceDataEvt(evt);\n\n              if (!this._paused) {\n                _context.next = 27;\n                break;\n              }\n\n              this._resuming = false;\n              return _context.abrupt(\"return\");\n\n            case 27:\n              _context.next = 3;\n              break;\n\n            case 29:\n              this._resuming = false;\n              Sockets.resume(this._id);\n\n            case 31:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this7 = this;\n\n      this._unregisterEvents();\n\n      this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n      this._errorListener = this._eventEmitter.addListener('error', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7.destroy();\n\n        _this7.emit('error', evt.error);\n      });\n      this._closeListener = this._eventEmitter.addListener('close', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7._setDisconnected();\n\n        _this7.emit('close', evt.error);\n      });\n      this._connectListener = this._eventEmitter.addListener('connect', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7._setConnected(evt.connection);\n\n        _this7.emit('connect');\n      });\n      this._writtenListener = this._eventEmitter.addListener('written', function (evt) {\n        if (evt.id !== _this7._id) return;\n\n        _this7._msgEvtEmitter.emit('written', evt);\n      });\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      var _this$_dataListener, _this$_errorListener, _this$_closeListener, _this$_connectListene, _this$_writtenListene;\n\n      (_this$_dataListener = this._dataListener) == null ? void 0 : _this$_dataListener.remove();\n      (_this$_errorListener = this._errorListener) == null ? void 0 : _this$_errorListener.remove();\n      (_this$_closeListener = this._closeListener) == null ? void 0 : _this$_closeListener.remove();\n      (_this$_connectListene = this._connectListener) == null ? void 0 : _this$_connectListene.remove();\n      (_this$_writtenListene = this._writtenListener) == null ? void 0 : _this$_writtenListene.remove();\n    }\n  }, {\n    key: \"_generateSendBuffer\",\n    value: function _generateSendBuffer(buffer, encoding) {\n      if (typeof buffer === 'string') {\n        return Buffer.from(buffer, encoding);\n      } else if (Buffer.isBuffer(buffer)) {\n        return buffer;\n      } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n        return Buffer.from(buffer);\n      } else {\n        throw new TypeError(\"Invalid data, chunk must be a string or buffer, not \" + typeof buffer);\n      }\n    }\n  }, {\n    key: \"_setDisconnected\",\n    value: function _setDisconnected() {\n      this._unregisterEvents();\n    }\n  }]);\n\n  return Socket;\n}(EventEmitter);\n\nexport { Socket as default };","map":{"version":3,"sources":["C:/Users/Massimiliano/Desktop/Perso/Programmation/Application_Mobile/SmartCage/node_modules/react-native-tcp-socket/src/Socket.js"],"names":["EventEmitter","Buffer","Sockets","NativeModules","TcpSockets","nativeEventEmitter","getNextId","Socket","_onDeviceDataEvt","evt","id","_id","_paused","bufferData","from","data","_bytesRead","byteLength","finalData","_encoding","toString","emit","_pausedDataEvents","push","undefined","_eventEmitter","_msgEvtEmitter","_timeoutMsecs","_timeout","_msgId","_lastRcvMsgId","Number","MAX_SAFE_INTEGER","_lastSentMsgId","_resuming","_writeBufferSize","_bytesWritten","_connecting","_pending","_destroyed","_readyState","readableHighWaterMark","writableHighWaterMark","writableNeedDrain","localAddress","localPort","remoteAddress","remotePort","remoteFamily","_registerEvents","connectionInfo","options","callback","_setId","customOptions","host","port","once","timeout","setTimeout","_activateTimer","tlsCert","Image","resolveAssetSource","uri","connect","_clearTimeout","clearTimeout","encoding","noDelay","setNoDelay","enable","initialDelay","setKeepAlive","console","warn","Math","floor","address","family","write","end","destroy","buffer","cb","self","Error","generatedBuffer","_generateSendBuffer","currentMsgId","msgEvtHandler","msgId","err","removeListener","on","ok","pause","_recoverDataEventsAfterPause","length","buffArray","readBytes","i","evtData","buffOffset","slice","concat","resume","_unregisterEvents","_dataListener","addListener","_errorListener","error","_closeListener","_setDisconnected","_connectListener","_setConnected","connection","_writtenListener","remove","isBuffer","Uint8Array","Array","isArray","TypeError"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAGA,OAAOA,YAAP,MAAyB,eAAzB;AACA,SAASC,MAAT,QAAuB,QAAvB;AACA,IAAMC,OAAO,GAAGC,aAAa,CAACC,UAA9B;AACA,SAASC,kBAAT,EAA6BC,SAA7B;;IAsCqBC,M;;;;;AAIjB,oBAAc;AAAA;;AAAA;;AACV;;AADU,UA2YdC,gBA3Yc,GA2YK,UAA8CC,GAA9C,EAAsD;AACrE,UAAIA,GAAG,CAACC,EAAJ,KAAW,MAAKC,GAApB,EAAyB;;AACzB,UAAI,CAAC,MAAKC,OAAV,EAAmB;AACf,YAAMC,UAAU,GAAGZ,MAAM,CAACa,IAAP,CAAYL,GAAG,CAACM,IAAhB,EAAsB,QAAtB,CAAnB;AACA,cAAKC,UAAL,IAAmBH,UAAU,CAACI,UAA9B;AACA,YAAMC,SAAS,GAAG,MAAKC,SAAL,GAAiBN,UAAU,CAACO,QAAX,CAAoB,MAAKD,SAAzB,CAAjB,GAAuDN,UAAzE;;AACA,cAAKQ,IAAL,CAAU,MAAV,EAAkBH,SAAlB;AACH,OALD,MAKO;AAEH,cAAKI,iBAAL,CAAuBC,IAAvB,CAA4Bd,GAA5B;AACH;AACJ,KAtZa;;AAGV,UAAKE,GAAL,GAAWa,SAAX;AAEA,UAAKC,aAAL,GAAqBpB,kBAArB;AAEA,UAAKqB,cAAL,GAAsB,IAAI1B,YAAJ,EAAtB;AAEA,UAAK2B,aAAL,GAAqB,CAArB;AAEA,UAAKC,QAAL,GAAgBJ,SAAhB;AAEA,UAAKL,SAAL,GAAiBK,SAAjB;AAEA,UAAKK,MAAL,GAAc,CAAd;AAEA,UAAKC,aAAL,GAAqBC,MAAM,CAACC,gBAAP,GAA0B,CAA/C;AAEA,UAAKC,cAAL,GAAsB,CAAtB;AAEA,UAAKrB,OAAL,GAAe,KAAf;AAEA,UAAKsB,SAAL,GAAiB,KAAjB;AAEA,UAAKC,gBAAL,GAAwB,CAAxB;AAEA,UAAKnB,UAAL,GAAkB,CAAlB;AAEA,UAAKoB,aAAL,GAAqB,CAArB;AAEA,UAAKC,WAAL,GAAmB,KAAnB;AAEA,UAAKC,QAAL,GAAgB,IAAhB;AAEA,UAAKC,UAAL,GAAkB,KAAlB;AAGA,UAAKC,WAAL,GAAmB,MAAnB;AAEA,UAAKlB,iBAAL,GAAyB,EAAzB;AACA,UAAKmB,qBAAL,GAA6B,KAA7B;AACA,UAAKC,qBAAL,GAA6B,KAA7B;AACA,UAAKC,iBAAL,GAAyB,KAAzB;AACA,UAAKC,YAAL,GAAoBpB,SAApB;AACA,UAAKqB,SAAL,GAAiBrB,SAAjB;AACA,UAAKsB,aAAL,GAAqBtB,SAArB;AACA,UAAKuB,UAAL,GAAkBvB,SAAlB;AACA,UAAKwB,YAAL,GAAoBxB,SAApB;;AACA,UAAKyB,eAAL;;AAjDU;AAkDb;;;;SAED,eAAiB;AACb,aAAO,KAAKT,WAAZ;AACH;;;SAED,eAAgB;AACZ,aAAO,KAAKD,UAAZ;AACH;;;SAED,eAAc;AACV,aAAO,KAAKD,QAAZ;AACH;;;SAED,eAAiB;AACb,aAAO,KAAKD,WAAZ;AACH;;;SAED,eAAmB;AACf,aAAO,KAAKD,aAAZ;AACH;;;SAED,eAAgB;AACZ,aAAO,KAAKpB,UAAZ;AACH;;;SAED,eAAc;AACV,aAAO,KAAKY,QAAZ;AACH;;;WAMD,gBAAOlB,EAAP,EAAW;AACP,WAAKC,GAAL,GAAWD,EAAX;;AACA,WAAKuC,eAAL;AACH;;;WAMD,uBAAcC,cAAd,EAA8B;AAC1B,WAAKb,WAAL,GAAmB,KAAnB;AACA,WAAKG,WAAL,GAAmB,MAAnB;AACA,WAAKF,QAAL,GAAgB,KAAhB;AACA,WAAKM,YAAL,GAAoBM,cAAc,CAACN,YAAnC;AACA,WAAKC,SAAL,GAAiBK,cAAc,CAACL,SAAhC;AACA,WAAKC,aAAL,GAAqBI,cAAc,CAACJ,aAApC;AACA,WAAKE,YAAL,GAAoBE,cAAc,CAACF,YAAnC;AACA,WAAKD,UAAL,GAAkBG,cAAc,CAACH,UAAjC;AACH;;;WAMD,iBAAQI,OAAR,EAAiBC,QAAjB,EAA2B;AACvB,UAAI,KAAKzC,GAAL,KAAaa,SAAjB,EAA4B,KAAK6B,MAAL,CAAY/C,SAAS,EAArB;;AAE5B,UAAMgD,aAAa,qBAAQH,OAAR,CAAnB;;AAEAG,MAAAA,aAAa,CAACC,IAAd,GAAqBD,aAAa,CAACC,IAAd,IAAsB,WAA3C;AACAD,MAAAA,aAAa,CAACE,IAAd,GAAqBzB,MAAM,CAACuB,aAAa,CAACE,IAAf,CAAN,IAA8B,CAAnD;AACA,WAAKC,IAAL,CAAU,SAAV,EAAqB,YAAM;AACvB,YAAIL,QAAJ,EAAcA,QAAQ;AACzB,OAFD;AAIA,UAAIE,aAAa,CAACI,OAAlB,EAA2B,KAAKC,UAAL,CAAgBL,aAAa,CAACI,OAA9B,EAA3B,KACK,IAAI,KAAK9B,QAAT,EAAmB,KAAKgC,cAAL;;AAExB,UAAIN,aAAa,CAACO,OAAlB,EAA2B;AACvBP,QAAAA,aAAa,CAACO,OAAd,GAAwBC,KAAK,CAACC,kBAAN,CAAyBT,aAAa,CAACO,OAAvC,EAAgDG,GAAxE;AACH;;AACD,WAAK3B,WAAL,GAAmB,IAAnB;AACA,WAAKG,WAAL,GAAmB,SAAnB;AACAtC,MAAAA,OAAO,CAAC+D,OAAR,CAAgB,KAAKtD,GAArB,EAA0B2C,aAAa,CAACC,IAAxC,EAA8CD,aAAa,CAACE,IAA5D,EAAkEF,aAAlE;AACA,aAAO,IAAP;AACH;;;WAeD,oBAAWI,OAAX,EAAoBN,QAApB,EAA8B;AAC1B,UAAIM,OAAO,KAAK,CAAhB,EAAmB;AACf,aAAKQ,aAAL;AACH,OAFD,MAEO;AACH,aAAKN,cAAL,CAAoBF,OAApB;AACH;;AACD,UAAIN,QAAJ,EAAc,KAAKK,IAAL,CAAU,SAAV,EAAqBL,QAArB;AACd,aAAO,IAAP;AACH;;;WAMD,wBAAeM,OAAf,EAAwB;AAAA;;AACpB,UAAIA,OAAO,KAAKlC,SAAhB,EAA2B,KAAKG,aAAL,GAAqB+B,OAArB;;AAC3B,WAAKQ,aAAL;;AACA,WAAKtC,QAAL,GAAgB+B,UAAU,CAAC,YAAM;AAC7B,QAAA,MAAI,CAACO,aAAL;;AACA,QAAA,MAAI,CAAC7C,IAAL,CAAU,SAAV;AACH,OAHyB,EAGvB,KAAKM,aAHkB,CAA1B;AAIH;;;WAKD,yBAAgB;AACZ,UAAI,KAAKC,QAAL,KAAkBJ,SAAtB,EAAiC;AAC7B2C,QAAAA,YAAY,CAAC,KAAKvC,QAAN,CAAZ;AACA,aAAKA,QAAL,GAAgBJ,SAAhB;AACH;AACJ;;;WAWD,qBAAY4C,QAAZ,EAAsB;AAClB,WAAKjD,SAAL,GAAiBiD,QAAjB;AACA,aAAO,IAAP;AACH;;;WAWD,sBAA2B;AAAA;;AAAA,UAAhBC,OAAgB,uEAAN,IAAM;;AACvB,UAAI,KAAK/B,QAAT,EAAmB;AACf,aAAKmB,IAAL,CAAU,SAAV,EAAqB;AAAA,iBAAM,MAAI,CAACa,UAAL,CAAgBD,OAAhB,CAAN;AAAA,SAArB;AACA,eAAO,IAAP;AACH;;AACDnE,MAAAA,OAAO,CAACoE,UAAR,CAAmB,KAAK3D,GAAxB,EAA6B0D,OAA7B;AACA,aAAO,IAAP;AACH;;;WAUD,wBAA+C;AAAA;;AAAA,UAAlCE,MAAkC,uEAAzB,KAAyB;AAAA,UAAlBC,YAAkB,uEAAH,CAAG;;AAC3C,UAAI,KAAKlC,QAAT,EAAmB;AACf,aAAKmB,IAAL,CAAU,SAAV,EAAqB;AAAA,iBAAM,MAAI,CAACgB,YAAL,CAAkBF,MAAlB,EAA0BC,YAA1B,CAAN;AAAA,SAArB;AACA,eAAO,IAAP;AACH;;AAED,UAAIA,YAAY,KAAK,CAArB,EAAwB;AACpBE,QAAAA,OAAO,CAACC,IAAR,CACI,iFADJ;AAGH;;AAEDzE,MAAAA,OAAO,CAACuE,YAAR,CAAqB,KAAK9D,GAA1B,EAA+B4D,MAA/B,EAAuCK,IAAI,CAACC,KAAL,CAAWL,YAAX,CAAvC;AACA,aAAO,IAAP;AACH;;;WAQD,mBAAU;AACN,UAAI,CAAC,KAAK5B,YAAV,EAAwB,OAAO,EAAP;AACxB,aAAO;AAAEkC,QAAAA,OAAO,EAAE,KAAKlC,YAAhB;AAA8BmC,QAAAA,MAAM,EAAE,KAAK/B,YAA3C;AAAyDQ,QAAAA,IAAI,EAAE,KAAKX;AAApE,OAAP;AACH;;;WAQD,aAAI9B,IAAJ,EAAUqD,QAAV,EAAoB;AAAA;;AAChB,UAAIrD,IAAJ,EAAU;AACN,aAAKiE,KAAL,CAAWjE,IAAX,EAAiBqD,QAAjB,EAA2B,YAAM;AAC7BlE,UAAAA,OAAO,CAAC+E,GAAR,CAAY,MAAI,CAACtE,GAAjB;AACH,SAFD;AAGA,eAAO,IAAP;AACH;;AACD,UAAI,KAAK2B,QAAL,IAAiB,KAAKC,UAA1B,EAAsC,OAAO,IAAP;;AAEtC,WAAK2B,aAAL;;AACAhE,MAAAA,OAAO,CAAC+E,GAAR,CAAY,KAAKtE,GAAjB;AACA,aAAO,IAAP;AACH;;;WAKD,mBAAU;AACN,UAAI,KAAK2B,QAAL,IAAiB,KAAKC,UAA1B,EAAsC,OAAO,IAAP;AACtC,WAAKA,UAAL,GAAkB,IAAlB;;AACA,WAAK2B,aAAL;;AACAhE,MAAAA,OAAO,CAACgF,OAAR,CAAgB,KAAKvE,GAArB;AACA,aAAO,IAAP;AACH;;;WAgBD,eAAMwE,MAAN,EAAcf,QAAd,EAAwBgB,EAAxB,EAA4B;AAAA;;AACxB,UAAMC,IAAI,GAAG,IAAb;AACA,UAAI,KAAK/C,QAAL,IAAiB,KAAKC,UAA1B,EAAsC,MAAM,IAAI+C,KAAJ,CAAU,mBAAV,CAAN;;AAEtC,UAAMC,eAAe,GAAG,KAAKC,mBAAL,CAAyBL,MAAzB,EAAiCf,QAAjC,CAAxB;;AACA,WAAKjC,gBAAL,IAAyBoD,eAAe,CAACtE,UAAzC;AACA,UAAMwE,YAAY,GAAG,KAAK5D,MAA1B;AACA,WAAKA,MAAL,GAAc,CAAC,KAAKA,MAAL,GAAc,CAAf,IAAoBE,MAAM,CAACC,gBAAzC;;AACA,UAAM0D,aAAa,GAAG,SAAhBA,aAAgB,CAA0DjF,GAA1D,EAAkE;AACpF,YAAQkF,KAAR,GAAuBlF,GAAvB,CAAQkF,KAAR;AAAA,YAAeC,GAAf,GAAuBnF,GAAvB,CAAemF,GAAf;;AACA,YAAID,KAAK,KAAKF,YAAd,EAA4B;AACxB,UAAA,MAAI,CAAC/D,cAAL,CAAoBmE,cAApB,CAAmC,SAAnC,EAA8CH,aAA9C;;AACA,UAAA,MAAI,CAACvD,gBAAL,IAAyBoD,eAAe,CAACtE,UAAzC;AACA,UAAA,MAAI,CAACa,aAAL,GAAqB6D,KAArB;AACA,cAAIN,IAAI,CAACzD,QAAT,EAAmByD,IAAI,CAACzB,cAAL;;AACnB,cAAI,MAAI,CAACjB,iBAAL,IAA0B,MAAI,CAACV,cAAL,KAAwB0D,KAAtD,EAA6D;AACzD,YAAA,MAAI,CAAChD,iBAAL,GAAyB,KAAzB;;AACA,YAAA,MAAI,CAACtB,IAAL,CAAU,OAAV;AACH;;AACD,cAAI+D,EAAJ,EAAQ;AACJ,gBAAIQ,GAAJ,EAASR,EAAE,CAAC,IAAIE,KAAJ,CAAUM,GAAV,CAAD,CAAF,CAAT,KACKR,EAAE;AACV;AACJ;AACJ,OAhBD;;AAkBA,WAAK1D,cAAL,CAAoBoE,EAApB,CAAuB,SAAvB,EAAkCJ,aAAlC,EAAiD,IAAjD;;AACA,UAAMK,EAAE,GAAG,KAAK5D,gBAAL,GAAwB,KAAKO,qBAAxC;AACA,UAAI,CAACqD,EAAL,EAAS,KAAKpD,iBAAL,GAAyB,IAAzB;AACT,WAAKV,cAAL,GAAsBwD,YAAtB;AACA,WAAKrD,aAAL,IAAsBmD,eAAe,CAACtE,UAAtC;AACAf,MAAAA,OAAO,CAAC8E,KAAR,CAAc,KAAKrE,GAAnB,EAAwB4E,eAAe,CAACnE,QAAhB,CAAyB,QAAzB,CAAxB,EAA4DqE,YAA5D;AACA,aAAOM,EAAP;AACH;;;WAKD,iBAAQ;AACJ,UAAI,KAAKnF,OAAT,EAAkB;AAClB,WAAKA,OAAL,GAAe,IAAf;AACAV,MAAAA,OAAO,CAAC8F,KAAR,CAAc,KAAKrF,GAAnB;AACA,WAAKU,IAAL,CAAU,OAAV;AACH;;;WAKD,kBAAS;AACL,UAAI,CAAC,KAAKT,OAAV,EAAmB;AACnB,WAAKA,OAAL,GAAe,KAAf;AACA,WAAKS,IAAL,CAAU,QAAV;;AACA,WAAK4E,4BAAL;AACH;;;WAED,eAAM;AACFvB,MAAAA,OAAO,CAACC,IAAR,CAAa,mEAAb;AACH;;;WAED,iBAAQ;AACJD,MAAAA,OAAO,CAACC,IAAR,CAAa,qEAAb;AACH;;;WAKD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACQ,KAAKzC,SADb;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAEI,mBAAKA,SAAL,GAAiB,IAAjB;;AAFJ;AAAA,oBAGW,KAAKZ,iBAAL,CAAuB4E,MAAvB,GAAgC,CAH3C;AAAA;AAAA;AAAA;;AAKcC,cAAAA,SALd,GAK0B,EAL1B;AAMYC,cAAAA,SANZ,GAMwB,CANxB;AAOYC,cAAAA,CAPZ,GAOgB,CAPhB;;AAAA;AAAA,oBAQeA,CAAC,GAAG,KAAK/E,iBAAL,CAAuB4E,MAR1C;AAAA;AAAA;AAAA;;AASkBI,cAAAA,OATlB,GAS4BrG,MAAM,CAACa,IAAP,CAAY,KAAKQ,iBAAL,CAAuB+E,CAAvB,EAA0BtF,IAAtC,EAA4C,QAA5C,CAT5B;AAUYqF,cAAAA,SAAS,IAAIE,OAAO,CAACrF,UAArB;;AAVZ,oBAWgBmF,SAAS,IAAI,KAAK3D,qBAXlC;AAAA;AAAA;AAAA;;AAYgB0D,cAAAA,SAAS,CAAC5E,IAAV,CAAe+E,OAAf;AAZhB;AAAA;;AAAA;AAcsBC,cAAAA,UAdtB,GAcmC,KAAK9D,qBAAL,GAA6B2D,SAdhE;AAegBD,cAAAA,SAAS,CAAC5E,IAAV,CAAe+E,OAAO,CAACE,KAAR,CAAc,CAAd,EAAiBD,UAAjB,CAAf;AACA,mBAAKjF,iBAAL,CAAuB+E,CAAvB,EAA0BtF,IAA1B,GAAiCuF,OAAO,CAACE,KAAR,CAAcD,UAAd,EAA0BnF,QAA1B,CAAmC,QAAnC,CAAjC;AAhBhB;;AAAA;AAQkDiF,cAAAA,CAAC,EARnD;AAAA;AAAA;;AAAA;AAqBc5F,cAAAA,GArBd,GAqBoB;AACRC,gBAAAA,EAAE,EAAE,KAAKY,iBAAL,CAAuB,CAAvB,EAA0BZ,EADtB;AAERK,gBAAAA,IAAI,EAAEd,MAAM,CAACwG,MAAP,CAAcN,SAAd,EAAyB/E,QAAzB,CAAkC,QAAlC;AAFE,eArBpB;AA0BQ,mBAAKE,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBkF,KAAvB,CAA6BH,CAA7B,CAAzB;;AACA,mBAAK7F,gBAAL,CAAsBC,GAAtB;;AA3BR,mBA4BY,KAAKG,OA5BjB;AAAA;AAAA;AAAA;;AA6BY,mBAAKsB,SAAL,GAAiB,KAAjB;AA7BZ;;AAAA;AAAA;AAAA;;AAAA;AAiCI,mBAAKA,SAAL,GAAiB,KAAjB;AACAhC,cAAAA,OAAO,CAACwG,MAAR,CAAe,KAAK/F,GAApB;;AAlCJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAwDA,2BAAkB;AAAA;;AACd,WAAKgG,iBAAL;;AACA,WAAKC,aAAL,GAAqB,KAAKnF,aAAL,CAAmBoF,WAAnB,CAA+B,MAA/B,EAAuC,KAAKrG,gBAA5C,CAArB;AACA,WAAKsG,cAAL,GAAsB,KAAKrF,aAAL,CAAmBoF,WAAnB,CAA+B,OAA/B,EAAwC,UAACpG,GAAD,EAAS;AACnE,YAAIA,GAAG,CAACC,EAAJ,KAAW,MAAI,CAACC,GAApB,EAAyB;;AACzB,QAAA,MAAI,CAACuE,OAAL;;AACA,QAAA,MAAI,CAAC7D,IAAL,CAAU,OAAV,EAAmBZ,GAAG,CAACsG,KAAvB;AACH,OAJqB,CAAtB;AAKA,WAAKC,cAAL,GAAsB,KAAKvF,aAAL,CAAmBoF,WAAnB,CAA+B,OAA/B,EAAwC,UAACpG,GAAD,EAAS;AACnE,YAAIA,GAAG,CAACC,EAAJ,KAAW,MAAI,CAACC,GAApB,EAAyB;;AACzB,QAAA,MAAI,CAACsG,gBAAL;;AACA,QAAA,MAAI,CAAC5F,IAAL,CAAU,OAAV,EAAmBZ,GAAG,CAACsG,KAAvB;AACH,OAJqB,CAAtB;AAKA,WAAKG,gBAAL,GAAwB,KAAKzF,aAAL,CAAmBoF,WAAnB,CAA+B,SAA/B,EAA0C,UAACpG,GAAD,EAAS;AACvE,YAAIA,GAAG,CAACC,EAAJ,KAAW,MAAI,CAACC,GAApB,EAAyB;;AACzB,QAAA,MAAI,CAACwG,aAAL,CAAmB1G,GAAG,CAAC2G,UAAvB;;AACA,QAAA,MAAI,CAAC/F,IAAL,CAAU,SAAV;AACH,OAJuB,CAAxB;AAKA,WAAKgG,gBAAL,GAAwB,KAAK5F,aAAL,CAAmBoF,WAAnB,CAA+B,SAA/B,EAA0C,UAACpG,GAAD,EAAS;AACvE,YAAIA,GAAG,CAACC,EAAJ,KAAW,MAAI,CAACC,GAApB,EAAyB;;AACzB,QAAA,MAAI,CAACe,cAAL,CAAoBL,IAApB,CAAyB,SAAzB,EAAoCZ,GAApC;AACH,OAHuB,CAAxB;AAIH;;;WAKD,6BAAoB;AAAA;;AAChB,kCAAKmG,aAAL,yCAAoBU,MAApB;AACA,mCAAKR,cAAL,0CAAqBQ,MAArB;AACA,mCAAKN,cAAL,0CAAqBM,MAArB;AACA,oCAAKJ,gBAAL,2CAAuBI,MAAvB;AACA,oCAAKD,gBAAL,2CAAuBC,MAAvB;AACH;;;WAOD,6BAAoBnC,MAApB,EAA4Bf,QAA5B,EAAsC;AAClC,UAAI,OAAOe,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,eAAOlF,MAAM,CAACa,IAAP,CAAYqE,MAAZ,EAAoBf,QAApB,CAAP;AACH,OAFD,MAEO,IAAInE,MAAM,CAACsH,QAAP,CAAgBpC,MAAhB,CAAJ,EAA6B;AAChC,eAAOA,MAAP;AACH,OAFM,MAEA,IAAIA,MAAM,YAAYqC,UAAlB,IAAgCC,KAAK,CAACC,OAAN,CAAcvC,MAAd,CAApC,EAA2D;AAC9D,eAAOlF,MAAM,CAACa,IAAP,CAAYqE,MAAZ,CAAP;AACH,OAFM,MAEA;AACH,cAAM,IAAIwC,SAAJ,0DACqD,OAAOxC,MAD5D,CAAN;AAGH;AACJ;;;WAKD,4BAAmB;AACf,WAAKwB,iBAAL;AACH;;;;EA1d+B3G,Y;;SAAfO,M","sourcesContent":["'use strict';\n\nimport { NativeModules, Image } from 'react-native';\nimport EventEmitter from 'eventemitter3';\nimport { Buffer } from 'buffer';\nconst Sockets = NativeModules.TcpSockets;\nimport { nativeEventEmitter, getNextId } from './Globals';\n\n/**\n * @typedef {\"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\"} BufferEncoding\n *\n * @typedef {import('react-native').NativeEventEmitter} NativeEventEmitter\n *\n * @typedef {{address: string, family: string, port: number}} AddressInfo\n *\n * @typedef {{localAddress: string, localPort: number, remoteAddress: string, remotePort: number, remoteFamily: string}} NativeConnectionInfo\n *\n * @typedef {{\n * port: number;\n * host?: string;\n * timeout?: number,\n * localAddress?: string,\n * localPort?: number,\n * interface?: 'wifi' | 'cellular' | 'ethernet',\n * reuseAddress?: boolean,\n * tls?: boolean,\n * tlsCheckValidity?: boolean,\n * tlsCert?: any,\n * }} ConnectionOptions\n *\n * @typedef {object} ReadableEvents\n * @property {() => void} pause\n * @property {() => void} resume\n *\n * @typedef {object} SocketEvents\n * @property {(had_error: boolean) => void} close\n * @property {() => void} connect\n * @property {(data: Buffer | string) => void} data\n * @property {() => void} drain\n * @property {(err: Error) => void} error\n * @property {() => void} timeout\n *\n * @extends {EventEmitter<SocketEvents & ReadableEvents, any>}\n */\nexport default class Socket extends EventEmitter {\n    /**\n     * Creates a new socket object.\n     */\n    constructor() {\n        super();\n        /** @private */\n        this._id = undefined;\n        /** @private */\n        this._eventEmitter = nativeEventEmitter;\n        /** @type {EventEmitter<'written', any>} @private */\n        this._msgEvtEmitter = new EventEmitter();\n        /** @type {number} @private */\n        this._timeoutMsecs = 0;\n        /** @type {number | undefined} @private */\n        this._timeout = undefined;\n        /** @private */\n        this._encoding = undefined;\n        /** @private */\n        this._msgId = 0;\n        /** @private */\n        this._lastRcvMsgId = Number.MAX_SAFE_INTEGER - 1;\n        /** @private */\n        this._lastSentMsgId = 0;\n        /** @private */\n        this._paused = false;\n        /** @private */\n        this._resuming = false;\n        /** @private */\n        this._writeBufferSize = 0;\n        /** @private */\n        this._bytesRead = 0;\n        /** @private */\n        this._bytesWritten = 0;\n        /** @private */\n        this._connecting = false;\n        /** @private */\n        this._pending = true;\n        /** @private */\n        this._destroyed = false;\n        // TODO: Add readOnly and writeOnly states\n        /** @type {'opening' | 'open' | 'readOnly' | 'writeOnly'} @private */\n        this._readyState = 'open'; // Incorrect, but matches NodeJS behavior\n        /** @type {{ id: number; data: string; }[]} @private */\n        this._pausedDataEvents = [];\n        this.readableHighWaterMark = 16384;\n        this.writableHighWaterMark = 16384;\n        this.writableNeedDrain = false;\n        this.localAddress = undefined;\n        this.localPort = undefined;\n        this.remoteAddress = undefined;\n        this.remotePort = undefined;\n        this.remoteFamily = undefined;\n        this._registerEvents();\n    }\n\n    get readyState() {\n        return this._readyState;\n    }\n\n    get destroyed() {\n        return this._destroyed;\n    }\n\n    get pending() {\n        return this._pending;\n    }\n\n    get connecting() {\n        return this._connecting;\n    }\n\n    get bytesWritten() {\n        return this._bytesWritten;\n    }\n\n    get bytesRead() {\n        return this._bytesRead;\n    }\n\n    get timeout() {\n        return this._timeout;\n    }\n\n    /**\n     * @package\n     * @param {number} id\n     */\n    _setId(id) {\n        this._id = id;\n        this._registerEvents();\n    }\n\n    /**\n     * @package\n     * @param {NativeConnectionInfo} connectionInfo\n     */\n    _setConnected(connectionInfo) {\n        this._connecting = false;\n        this._readyState = 'open';\n        this._pending = false;\n        this.localAddress = connectionInfo.localAddress;\n        this.localPort = connectionInfo.localPort;\n        this.remoteAddress = connectionInfo.remoteAddress;\n        this.remoteFamily = connectionInfo.remoteFamily;\n        this.remotePort = connectionInfo.remotePort;\n    }\n\n    /**\n     * @param {ConnectionOptions} options\n     * @param {() => void} [callback]\n     */\n    connect(options, callback) {\n        if (this._id === undefined) this._setId(getNextId());\n\n        const customOptions = { ...options };\n        // Normalize args\n        customOptions.host = customOptions.host || 'localhost';\n        customOptions.port = Number(customOptions.port) || 0;\n        this.once('connect', () => {\n            if (callback) callback();\n        });\n        // Timeout\n        if (customOptions.timeout) this.setTimeout(customOptions.timeout);\n        else if (this._timeout) this._activateTimer();\n        // TLS Cert\n        if (customOptions.tlsCert) {\n            customOptions.tlsCert = Image.resolveAssetSource(customOptions.tlsCert).uri;\n        }\n        this._connecting = true;\n        this._readyState = 'opening';\n        Sockets.connect(this._id, customOptions.host, customOptions.port, customOptions);\n        return this;\n    }\n\n    /**\n     * Sets the socket to timeout after `timeout` milliseconds of inactivity on the socket. By default `TcpSocket` do not have a timeout.\n     *\n     * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed.\n     * The user must manually call `socket.end()` or `socket.destroy()` to end the connection.\n     *\n     * If `timeout` is 0, then the existing idle timeout is disabled.\n     *\n     * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.\n     *\n     * @param {number} timeout\n     * @param {() => void} [callback]\n     */\n    setTimeout(timeout, callback) {\n        if (timeout === 0) {\n            this._clearTimeout();\n        } else {\n            this._activateTimer(timeout);\n        }\n        if (callback) this.once('timeout', callback);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} [timeout]\n     */\n    _activateTimer(timeout) {\n        if (timeout !== undefined) this._timeoutMsecs = timeout;\n        this._clearTimeout();\n        this._timeout = setTimeout(() => {\n            this._clearTimeout();\n            this.emit('timeout');\n        }, this._timeoutMsecs);\n    }\n\n    /**\n     * @private\n     */\n    _clearTimeout() {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n    }\n\n    /**\n     * Set the encoding for the socket as a Readable Stream. By default, no encoding is assigned and stream data will be returned as `Buffer` objects.\n     * Setting an encoding causes the stream data to be returned as strings of the specified encoding rather than as Buffer objects.\n     *\n     * For instance, calling `socket.setEncoding('utf8')` will cause the output data to be interpreted as UTF-8 data, and passed as strings.\n     * Calling `socket.setEncoding('hex')` will cause the data to be encoded in hexadecimal string format.\n     *\n     * @param {BufferEncoding} [encoding]\n     */\n    setEncoding(encoding) {\n        this._encoding = encoding;\n        return this;\n    }\n\n    /**\n     * Enable/disable the use of Nagle's algorithm. When a TCP connection is created, it will have Nagle's algorithm enabled.\n     *\n     * Nagle's algorithm delays data before it is sent via the network. It attempts to optimize throughput at the expense of latency.\n     *\n     * Passing `true` for `noDelay` or not passing an argument will disable Nagle's algorithm for the socket. Passing false for noDelay will enable Nagle's algorithm.\n     *\n     * @param {boolean} noDelay Default: `true`\n     */\n    setNoDelay(noDelay = true) {\n        if (this._pending) {\n            this.once('connect', () => this.setNoDelay(noDelay));\n            return this;\n        }\n        Sockets.setNoDelay(this._id, noDelay);\n        return this;\n    }\n\n    /**\n     * Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket.\n     *\n     * `initialDelay` is ignored.\n     *\n     * @param {boolean} enable Default: `false`\n     * @param {number} initialDelay ***IGNORED**. Default: `0`\n     */\n    setKeepAlive(enable = false, initialDelay = 0) {\n        if (this._pending) {\n            this.once('connect', () => this.setKeepAlive(enable, initialDelay));\n            return this;\n        }\n\n        if (initialDelay !== 0) {\n            console.warn(\n                'react-native-tcp-socket: initialDelay param in socket.setKeepAlive() is ignored'\n            );\n        }\n\n        Sockets.setKeepAlive(this._id, enable, Math.floor(initialDelay));\n        return this;\n    }\n\n    /**\n     * Returns the bound `address`, the address `family` name and `port` of the socket as reported\n     * by the operating system: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n     *\n     * @returns {AddressInfo | {}}\n     */\n    address() {\n        if (!this.localAddress) return {};\n        return { address: this.localAddress, family: this.remoteFamily, port: this.localPort };\n    }\n\n    /**\n     * Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data.\n     *\n     * @param {string | Buffer | Uint8Array} [data]\n     * @param {BufferEncoding} [encoding]\n     */\n    end(data, encoding) {\n        if (data) {\n            this.write(data, encoding, () => {\n                Sockets.end(this._id);\n            });\n            return this;\n        }\n        if (this._pending || this._destroyed) return this;\n\n        this._clearTimeout();\n        Sockets.end(this._id);\n        return this;\n    }\n\n    /**\n     * Ensures that no more I/O activity happens on this socket. Destroys the stream and closes the connection.\n     */\n    destroy() {\n        if (this._pending || this._destroyed) return this;\n        this._destroyed = true;\n        this._clearTimeout();\n        Sockets.destroy(this._id);\n        return this;\n    }\n\n    /**\n     * Sends data on the socket. The second parameter specifies the encoding in the case of a string â€” it defaults to UTF8 encoding.\n     *\n     * Returns `true` if the entire data was flushed successfully to the kernel buffer. Returns `false` if all or part of the data\n     * was queued in user memory. `'drain'` will be emitted when the buffer is again free.\n     *\n     * The optional callback parameter will be executed when the data is finally written out, which may not be immediately.\n     *\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     * @param {(err?: Error) => void} [cb]\n     *\n     * @return {boolean}\n     */\n    write(buffer, encoding, cb) {\n        const self = this;\n        if (this._pending || this._destroyed) throw new Error('Socket is closed.');\n\n        const generatedBuffer = this._generateSendBuffer(buffer, encoding);\n        this._writeBufferSize += generatedBuffer.byteLength;\n        const currentMsgId = this._msgId;\n        this._msgId = (this._msgId + 1) % Number.MAX_SAFE_INTEGER;\n        const msgEvtHandler = (/** @type {{id: number, msgId: number, err?: string}} */ evt) => {\n            const { msgId, err } = evt;\n            if (msgId === currentMsgId) {\n                this._msgEvtEmitter.removeListener('written', msgEvtHandler);\n                this._writeBufferSize -= generatedBuffer.byteLength;\n                this._lastRcvMsgId = msgId;\n                if (self._timeout) self._activateTimer();\n                if (this.writableNeedDrain && this._lastSentMsgId === msgId) {\n                    this.writableNeedDrain = false;\n                    this.emit('drain');\n                }\n                if (cb) {\n                    if (err) cb(new Error(err));\n                    else cb();\n                }\n            }\n        };\n        // Callback equivalent with better performance\n        this._msgEvtEmitter.on('written', msgEvtHandler, this);\n        const ok = this._writeBufferSize < this.writableHighWaterMark;\n        if (!ok) this.writableNeedDrain = true;\n        this._lastSentMsgId = currentMsgId;\n        this._bytesWritten += generatedBuffer.byteLength;\n        Sockets.write(this._id, generatedBuffer.toString('base64'), currentMsgId);\n        return ok;\n    }\n\n    /**\n     * Pauses the reading of data. That is, `'data'` events will not be emitted. Useful to throttle back an upload.\n     */\n    pause() {\n        if (this._paused) return;\n        this._paused = true;\n        Sockets.pause(this._id);\n        this.emit('pause');\n    }\n\n    /**\n     * Resumes reading after a call to `socket.pause()`.\n     */\n    resume() {\n        if (!this._paused) return;\n        this._paused = false;\n        this.emit('resume');\n        this._recoverDataEventsAfterPause();\n    }\n\n    ref() {\n        console.warn('react-native-tcp-socket: Socket.ref() method will have no effect.');\n    }\n\n    unref() {\n        console.warn('react-native-tcp-socket: Socket.unref() method will have no effect.');\n    }\n\n    /**\n     * @private\n     */\n    async _recoverDataEventsAfterPause() {\n        if (this._resuming) return;\n        this._resuming = true;\n        while (this._pausedDataEvents.length > 0) {\n            // Concat all buffered events for better performance\n            const buffArray = [];\n            let readBytes = 0;\n            let i = 0;\n            for (; i < this._pausedDataEvents.length; i++) {\n                const evtData = Buffer.from(this._pausedDataEvents[i].data, 'base64');\n                readBytes += evtData.byteLength;\n                if (readBytes <= this.readableHighWaterMark) {\n                    buffArray.push(evtData);\n                } else {\n                    const buffOffset = this.readableHighWaterMark - readBytes;\n                    buffArray.push(evtData.slice(0, buffOffset));\n                    this._pausedDataEvents[i].data = evtData.slice(buffOffset).toString('base64');\n                    break;\n                }\n            }\n            // Generate new event with the concatenated events\n            const evt = {\n                id: this._pausedDataEvents[0].id,\n                data: Buffer.concat(buffArray).toString('base64'),\n            };\n            // Clean the old events\n            this._pausedDataEvents = this._pausedDataEvents.slice(i);\n            this._onDeviceDataEvt(evt);\n            if (this._paused) {\n                this._resuming = false;\n                return;\n            }\n        }\n        this._resuming = false;\n        Sockets.resume(this._id);\n    }\n\n    /**\n     * @private\n     */\n    _onDeviceDataEvt = (/** @type {{ id: number; data: string; }} */ evt) => {\n        if (evt.id !== this._id) return;\n        if (!this._paused) {\n            const bufferData = Buffer.from(evt.data, 'base64');\n            this._bytesRead += bufferData.byteLength;\n            const finalData = this._encoding ? bufferData.toString(this._encoding) : bufferData;\n            this.emit('data', finalData);\n        } else {\n            // If the socket is paused, save the data events for later\n            this._pausedDataEvents.push(evt);\n        }\n    };\n\n    /**\n     * @private\n     */\n    _registerEvents() {\n        this._unregisterEvents();\n        this._dataListener = this._eventEmitter.addListener('data', this._onDeviceDataEvt);\n        this._errorListener = this._eventEmitter.addListener('error', (evt) => {\n            if (evt.id !== this._id) return;\n            this.destroy();\n            this.emit('error', evt.error);\n        });\n        this._closeListener = this._eventEmitter.addListener('close', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setDisconnected();\n            this.emit('close', evt.error);\n        });\n        this._connectListener = this._eventEmitter.addListener('connect', (evt) => {\n            if (evt.id !== this._id) return;\n            this._setConnected(evt.connection);\n            this.emit('connect');\n        });\n        this._writtenListener = this._eventEmitter.addListener('written', (evt) => {\n            if (evt.id !== this._id) return;\n            this._msgEvtEmitter.emit('written', evt);\n        });\n    }\n\n    /**\n     * @private\n     */\n    _unregisterEvents() {\n        this._dataListener?.remove();\n        this._errorListener?.remove();\n        this._closeListener?.remove();\n        this._connectListener?.remove();\n        this._writtenListener?.remove();\n    }\n\n    /**\n     * @private\n     * @param {string | Buffer | Uint8Array} buffer\n     * @param {BufferEncoding} [encoding]\n     */\n    _generateSendBuffer(buffer, encoding) {\n        if (typeof buffer === 'string') {\n            return Buffer.from(buffer, encoding);\n        } else if (Buffer.isBuffer(buffer)) {\n            return buffer;\n        } else if (buffer instanceof Uint8Array || Array.isArray(buffer)) {\n            return Buffer.from(buffer);\n        } else {\n            throw new TypeError(\n                `Invalid data, chunk must be a string or buffer, not ${typeof buffer}`\n            );\n        }\n    }\n\n    /**\n     * @private\n     */\n    _setDisconnected() {\n        this._unregisterEvents();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}